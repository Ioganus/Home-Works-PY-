# # ПРИМЕР ЦИКЛА for
# S = 0  # заводим переменную-счетчик, в которой мы будем считать сумму
# N = 5


# # ЗАВОДИМ ЦИКЛ FOR, В КОТОРОМ МЫ БУДЕМ ПРОХОДИТЬ ПО ВСЕМ ЧИСЛАМ ОТ ОДНОГО ДО N
# for i in range(1, N + 1):  # равносильно выражению for i in [1, 2, 3, ... , N -1, N]:
#     print("Значение суммы на предыдущем шаге: ", S)
#     print("Текущее число: ", i)
#     S = S + i  # cуммируем текущее число i и перезаписываем значение суммы
#     print("Значение суммы после сложения: ", S)
#     print("---")
# print("Конец цикла")
# print()
# print("Ответ: сумма равна = ", S)


# # ПРОИЗВЕДЕНИЕ С ПОМОЩЬЮ ЦИКЛА
# #  """обратите внимание, что P = 1, это важно, потому что если бы
# # мы умножали на 0, то все произведение было бы равно 0"""
# P = 1  # заводим переменную-счетчик, в которой мы будем считать произведение
# N = 5
# # запишите цикл for для подсчета произведения
# for i in range(1, N+1):
#     P *= i
# print(P)


# # ЦИКЛ, КОТОРЫЙ БУДЕТ СКЛАДЫВАТЬ НАТУРАЛЬНЫЕ ЧИСЛА, ПОКА ИХ СУММА НЕ ПРЕВЫСИТ 500
# S = 0  # заводим переменную-счетчик, в которой мы будем считать сумму
# n = 1  # текущее натуральное число
# # заводим цикл while, который будет работать, пока сумма не превысит 500
# while S < 500:
#     S += n  # увеличиваем сумму, равносильно S = S + n
#     n += 1  # так как сумма ещё не достигла нужного значения, то увеличиваем переменную-счетчик
#     print("Ещё считаю ...")
# print("Сумма равна:", S)
# print("Количество чисел:", n)


# # ЦИКЛ КОТОРЫЙ ВОЗВОДИТ ЧИСЛА В КВАДРАТ, ПОКА РЕЗУЛЬТАТ МЕНЬШЕ 1000
# n = 1
# while n ** 2 < 1000:
#     n += 1


# # ЦИКЛ С ИСПОЛЬЗОВАНИЕМ БЕСКОНЕЧНОГО ЦИКЛА WHILЕ С ПОСТУСЛОВИЕМ, 
# # КОТОРЫЙ ВОЗВОДИТ НАТУРАЛЬНЫЕ ЧИСЛА В КВАДРАТ, ПОКА РЕЗУЛЬТАТ МЕНЬШЕ 1000
# n = 1
# while True:
#     if n ** 2 >= 1000:
#         print("Последнее число", n - 1)
#         break
#     n += 1


# # УСЛОВИЕ ЗАДАЧИ. ДАНА ДВУМЕРНАЯ МАТРИЦА 3X3. 
# # ОПРЕДЕЛИТЕ МАКСИМУМ И МИНИМУМ КАЖДОЙ СТРОКИ, А ТАКЖЕ ИХ ИНДЕКСЫ.
# random_matrix = [
# [9, 2, 1],
# [2, 5, 3],
# [4, 8, 5]
# ]
# min_value_rows = []  # здесь будут храниться минимальные значения для каждой строки
# min_index_rows = []  # здесь будут храниться индексы минимальных значений для каждой строки
# max_value_rows = []  # здесь будут храниться максимальные значения для каждой строки
# max_index_rows = []  # здесь будут храниться индексы максимальных значений для каждой строки
# for row in random_matrix:  # здесь мы целиком берем каждую сроку
#     min_index = 0  # в качестве минимального значения возьмем первый элемент строки
#     max_index = 0
#     min_value = row[min_index]  # начальное минимальное значение для каждой строки будет новое
#     max_value = row[max_index]  # для максимального значения тоже самое
#     for index_col in range(len(row)):
#         if row[index_col] < min_value:
#             min_value = row[index_col]
#             min_index = index_col
#         if row[index_col] > max_value:
#             max_value = row[index_col]
#             max_index = index_col
#     min_value_rows.append(min_value)
#     min_index_rows.append(min_index)
#     max_value_rows.append(max_value)
#     max_index_rows.append(max_index)
# print(min_value_rows)
# print(min_index_rows)
# print(max_value_rows)
# print(max_index_rows)


# # ENUMERATE
# list_ = [-5, 2, 4, 8, 12, -7, 5]
# # Функция enumerate возвращает данные в виде кортежей, 
# # где на первом месте стоит индекс, а затем значение 
# # [(0, -5), (1, 2), (2, 4), ...]
# for i, value in enumerate(list_):  
#     print("Индекс элемента: ", i)
#     print("Значение элемента: ", value)  # с помощью индекса получаем значение элемента
#     print("---")
# print("Конец цикла")


# #ЦИКЛ КОТОРSQ НАХОДИТ ИНДЕКС ПОСЛЕДНЕГО ОТРИЦАТЕЛЬНОГО ЭЛЕМЕНТА В СПИСКЕ
# list_ = [-5, 2, 4, 8, 12, -7, 5]
# # Объявим переменную, в которой будем хранить индекс отрицательного элемента
# index_negative = None
# for i, value in enumerate(list_):
#     if value < 0:
#         print("Отрицательное число: ", value)
#         index_negative = i  # перезаписываем значение индекса
#         print("Новый индекс отрицательного числа: ", index_negative)
#     else:
#         print("Положительное число: ", value)
#     print("---")
# print("Конец цикла")
# print()
# print("Ответ: индекс последнего отрицательного элемента = ", index_negative)


# #КОЛ-ВО КРОЛИКОВ И ФАЗАНОВ В КЛЕТКЕ (В ОБЩЕМ 35 ГОЛОВ И 94 НОГИ)
# heads = 35  # количество голов
# legs = 94  # количество ног
# for r in range(heads + 1):  # количество кроликов
#     for ph in range(heads + 1):  # количество фазанов
#         #  если суммарное количество голов превышено или ног превышено, то переходим на следующий шаг цикла
#         if (r + ph) > heads or \
#             (r * 4 + ph * 2) > legs: 
#             continue
#         if (r + ph) == heads and (r * 4 + ph * 2) == legs:
#             print("Количество кроликов", r)
#             print("Количество фазанов", ph)
#             print("---")


#В PYTHON ЕСТЬ ФУНКЦИЯ ALL([ ]), КОТОРАЯ ВОЗВРАЩАЕТ TRUE, ЕСЛИ ВСЕ УСЛОВИЯ, 
# ПЕРЕДАННЫЕ В АРГУМЕНТ ФУНКЦИИ В ВИДЕ СПИСКА, ЯВЛЯЮТСЯ ИСТИННЫМИ
# if all([type(a) == int,
#         100 <= a <= 999,
#         a % 2 == 0,
#         a % 3 == 0]):
#     print("Число удовлетворяет условиям")
# А ЕСЛИ НУЖНО ЧТОБЫ БЫЛ ХОТЯ БЫ ОДИН ИСТИННЫЙ 
# НА ПОМОЩЬ ПРИХОДИТ ФУНКЦИЯ ANY([ ])


# #ПРОГРАММA, КОТОРАЯ СЧИТАЕТ ПОСЛЕДОВАТЕЛЬНОСТЬ СИМВОЛОВ
# text = input() # получаем строку

# first = text[0] # сохраняем первый символ
# count = 0 # заводим счетчик
# result = '' # и результирующую строку

# for c in text:
#     if c == first: # если символ совпадает с сохраненным, 
#         count += 1 # то увеличиваем счетчик
#     else:
#         result += first + str(count) # иначе - записываем в результат
#         first = c # и обновляем сохраненный символ с его счетчиком
#         count = 1
# result += first + str(count) # и добавляем в результат последний символ
# print(result)


# # ПРИНЦИП СОЗДАНИЯ И ВЫЗОВА ФУНКЦИИ
# # 1
# def print_2_add_2():
#     result = 2 + 2
#     print(result)
# print_2_add_2()

# # 2
# def hello_world ():
#     print ("hello_world")
# hello_world()

# # 3
# a = int(input())
# n = int(input())
# def delitel (a,n) :
#     if a % n == 0:
#         print (f"Число {n} является делитиелем числа {a}")
#     else:
#         print (f"Число {n} не является делитиелем числа {a}")
# delitel(a,n)

# # ФУНКЦИЯ, КОТОРАЯ ПРОВЕРЯЕТ, ЯВЛЯЕТСЯ ЛИ СТРОКА ПАЛИНДРОМОМ ИЛИ НЕТ, И ВОЗВРАЩАЕТ РЕЗУЛЬТАТ ПРОВЕРКИ.
# def check_palindrome(str_):
#     str_ = str_.lower()
#     str_ = str_.replace(" ", "")

#     if str_ == str_[::-1]:
#         return True
#     else:
#         return False

# check_palindrome("test")  # False
# check_palindrome("Кит на море не романтик")  # True

# ВВОД ВНУТРИ ТЕЛА ФУНКЦИИ
# # def func (a,b):
# #     a = int(input())
# #     b = int(input())
# #     result= a+b
# #     return result
# # c = func (0,0)
# # print (c)


# # ОПЕРАТОР РАСПАКОВКИ

# # Оператор * чаще всего ассоциируется с операцией умножения, но в Python он имеет и другой смысл. 
# # Этот оператор позволяет «распаковывать» (получить все значения из какой-либо последовательности,) 
# # объекты (например, списки или кортежи), внутри которых хранятся некие элементы. Не используя 
# # оператор распаковки, если мы захотим поместить список а в список b, просто укажем его в качестве
# # одного из элементов нового списка. Но если мы захотим добавить именно значение из первого списка,
# # а не сам список, то оператор распаковки сделает это, то есть вытащит из списка все значения.

# a = [1, 2, 3]
# b = [a, 4, 5, 6]
# print(b)
# # [[1, 2, 3], 4, 5, 6]

# a = [1, 2, 3]
# b = [*a, 4, 5, 6]
# print(b)
# # [1, 2, 3, 4, 5, 6]


# # УНИВЕРСАЛЬНЫЙ ШАБЛОН ДЕКОРАТОРА

# def my_decorator(fn):
#     print("Этот код будет выведен один раз в момент декорирования функции")
#     def wrapper(*args, **kwargs):
#         print('Этот код будет выполняться перед каждым вызовом функции')
#         result = fn(*args, **kwargs)
#         print('Этот код будет выполняться после каждого вызова функции')
#         return result
#     return wrapper


# # ФУНКЦИЯ РЕШАЮЩАЯ КВАДРАТНЫЕ УРАВНЕНИЯ

# # a*x**2 + b*x + c = 0 - общий вид уравнения
# # D = b**2 - 4*a*c - дискриминант
# # Если D<0, то уравнение не имеет вещественных корней
# # Если D=0, то уравнение имеет один корень  x = -b/(2*a)
# # Если D>0, то уравнение имеет два корня
# # x1 = (-b - D**0.5)/(2*a)
# # x2 = (-b + D**0.5)/(2*a)
# #
# # P.S. D**0.5 - равносильно извлечению квадратного корня

# def linear_solve(a, b):
#     if a: 
#         return b/a
#     elif not a and not b: # снова используем числа в логических выражениях
#         return "Бесконечное количество корней"
#     else:
#         return "Нет корней"

# # Напишем функцию D(a,b,c), возвращающую дискриминант квадратного уравнения
# def D(a,b,c):
#     return b**2 - 4*a*c
# # Следующим этапом реализуем функцию, возвращающую «Нет вещественных корней», если дискриминант отрицательный

# # Реализуем функцию quadratic_solve(a,b,c), возвращающую «Нет вещественных корней» в случае отрицательного дискриминанта.
# def quadratic_solve(a,b,c):
#     if D(a,b,c) < 0:
#         return "Нет вещественных корней"
# # Далее модифицируем функцию таким образом, чтобы при нулевом дискриминанте возвращалось значение единственного корня

# # Модифицируем функцию quadratic_solve(a,b,c), чтобы она возвращала единственный корень при условии нулевого дискриминанта
# def quadratic_solve(a,b,c):
#     if D(a,b,c) < 0:
#         return "Нет вещественных корней"
#     elif D(a,b,c) == 0:
#         return -b/(2*a)

# # Конечный вид функции возвращающей сразу два значения будет выглядеть так:
# def quadratic_solve(a,b,c):
#     if D(a,b,c) < 0:
#         return "Нет вещественных корней"
#     elif D(a,b,c) == 0:
#         return -b/(2*a)
#     else:
#         return (-b-D(a,b,c)**0.5)/(2*a), (-b+D(a,b,c)**0.5)/(2*a)


# # РЕКУРСИВНАЯ ФУНКЦИЯ, НАХОДЯЩУЯ МИНИМАЛЬНЫЙ ЭЛЕМЕНТ СПИСКА БЕЗ ИСПОЛЬЗОВАНИЯ ЦИКЛОВ И ВСТРОЕННОЙ ФУНКЦИИ min()
# def min_list(L):
#     if len(L) == 1:
#         return L[0]
#     return L[0] if L[0] < min_list(L[1:]) else min_list(L[1:])


# # РЕКУРСИВНАЯ ФУНКЦИЯ, КОТОРАЯ ЗЕРКАЛЬНО РАЗВОРАЧИВАЕТ ЧИСЛО. ПРЕДПОЛАГАЕТСЯ, ЧТО ЧИСЛО НЕ СОДЕРЖИТ НУЛИ
# def mirror(a, res=0):
#     if a == 0:
#         return res
#     else:
#         return mirror(a // 10, res * 10 + a % 10)


# # ФУНКЦИЯ EQUAL(N, S), ПРОВЕРЯЮЩАЯ, СОВПАДАЕТ ЛИ СУММА ЦИФР ЧИСЛА N С ЧИСЛОМ S.
# # ЕСЛИ S СТАЛА ОТРИЦАТЕЛЬНОЙ, ТО НЕОБХОДИМО СРАЗУ ВЕРНУТЬ FALSE
# def equal(N, S):
#     if S < 0:
#         return False
#     if N < 10:
#         return N == S
#     else:
#         return equal(N // 10, S - N % 10) 


# ГЕНЕРАТОР ДЛЯ ПРИБЛИЖЕННОГО ВЫЧИСЛЕНИЯ ЧИСЛА E = 2.718. ДЛЯ НАХОЖДЕНИЯ ЧИСЛА, УДОВЛЕТВОРЯЮЩЕГО НЕОБХОДИМОЙ ТОЧНОСТИ БУДЕМ ИСПОЛЬЗОВАТЬ СЛЕДУЮЩИЙ ЦИКЛ:
# last = 0
# for a in e(): # e() - генератор
#     if (a - last) < 0.00000001: # ограничение на точность
#         print(a)
#         break # после достижения которого - завершаем цикл
#     else:
#         last = a # иначе - присваиваем новое значение 
# Для вычисления числа e с определенной точностью можно использовать формулу:
# e_n = (1 + 1/n)**n
# В этой формуле число n — натуральное (1, 2, 3 и т. д.)


# # ФУНКЦИZ-ГЕНЕРАТОР, КАЖДОЕ ЗНАЧЕНИЕ КОТОРОГО — ПРИБЛИЖЕНИЕ ЧИСЛА E С НЕКОТОРЫМ ЧИСЛОМ N.

# def e():
#     n = 1
#     while True:
#         yield (1+1/n)**n
#         n += 1

# # ИТЕРАТОР СТРОКИ
# iter_obj = iter("Hello!")
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))


# ЧАЩЕ ВСЕГО ГЕНЕРАТОРЫ СПИСКОВ БОЛЕЕ ЧИТАЕМЫ, ЧЕМ MAP И FILTER, ОСОБЕННО В ПРОСТЫХ КОНСТРУКЦИЯХ

# # map + filter
# some_list = [i - 10 for i in range(20)]
# def pow2(x): return x**2
# def positive(x): return x > 0
# print(some_list)
# print(list(map(pow2, filter(positive, some_list))))

# # И ТОЖЕ САМОЕ ЧЕРЕЗ LIST COMPREHENSION:
# [i**2 for i in some_list if i > 0]
# ----------------------------------------------------------------
# map(func, list1)  # итератор, но никаких вычислений не будет произведено
# list(map(...))  # только здесь появляется объект
# [func(i) for i in list1]  # сразу готовый объект
# [func(i) for i in list1] == list(map(func, list1))  # результат один и тот же

# # LAMBDA-ФУНКЦИИ
# # ФУНКЦИИ MAP И FILTER ПРИНИМАЮТ В ВИДЕ ПЕРВОГО АРГУМЕНТА ДРУГУЮ ФУНКЦИЮ, КОТОРАЯ ДОЛЖНА ПРИМЕНЯТЬСЯ К КАЖДОМУ ЭЛЕМЕНТУ. 
# # ИНОГДА ВСТРОЕННЫХ ФУНКЦИЙ НЕ ХВАТАЕТ, И ПРИХОДИТСЯ ОБЪЯВЛЯТЬ ФУНКЦИЮ, КОТОРАЯ ЗАЧАСТУЮ БУДЕТ ПРИМЕНЕНА ВСЕГО ОДИН РАЗ. 
# # НО ПРИ ЭТОМ ОНА БУДЕТ ЗАГРОМОЖДАТЬ ИСХОДНЫЙ КОД.
# # СПЕЦИАЛЬНО ДЛЯ ТАКИХ ОДНОРАЗОВЫХ ФУНКЦИЙ БЫЛИ СДЕЛАНЫ АНОНИМНЫЕ ФУНКЦИИ. 
# # ОБЪЯВЛЯЮТСЯ ОНИ ПО КЛЮЧЕВОМУ СЛОВУ LAMBDA.

# # Эти две функции выполняют одно и тоже — складывают два числа
# def my_function(x1, x2):  # Обычная функция
#     return x2 + x1

# lambda x1, x2: x2 + x1  # Анонимная функция

# # Анонимные функции могут содержать в себе только одну инструкцию которую они выполняют.
# # Возвести первые 10 натуральных чисел в квадрат
# list(map(lambda x: x ** 2, range(1, 11)))  # правильно
# # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# list(map(lambda x: x ** 2; x + 1, range(1, 11)))  #  неправильно, так как lambda содержит две инструкции


# # РАССМОТРИМ НЕСКОЛЬКО ПРИМЕРОВ В КОТОРЫХ ИСПОЛЬЗУЮТ ДАННЫЕ ФУНКЦИИ.

# # Предположим, мы хотим отсортировать словарь по значениям. 
# # Словарь (ассоциативный массив) является неупорядоченной структурой данных. 
# # Иными словами, порядок хранения пар ключ-значение в памяти может быть произвольным. 
# # Однако создатели языка Python, начиная с версии 3.6, изменили реализацию словарей таким образом, 
# # что порядок ключей «запоминается». И потому упорядочивание словаря в Python становится осмысленным. 
# # По умолчанию словарь сортируется по ключам.

# d = {2 : "c", 1 : "d", 4 : "a", 3 : "b"} # dictionary 

# # Чтобы отсортировать его по ключам, нужно сделать так:
# print(dict(sorted(d.items())))  
# # {1: 'd', 2: 'c', 3: 'b', 4: 'a'}

# # А вот чтобы отсортировать словарь по значениям, необходимо указать, 
# # что сортировать нужно по второму элементу кортежа ключ-значение. 
# # Тут на помощь приходят lambda-функции. У встроенной функции sortred()
# # можно задать аргумент key, который укажет, по какому ключу нужно производить сортировку.

# sorted(d.items(), key=lambda x: x[1])  # сортировка по значению словаря


# # ЗАДАЧА 1

# # # Предположим у нас есть список с данными о росте и весе людей. 
# # # Задача — отсортировать их по индексу массы тела. 
# # # Он вычисляется по формуле: рост в метрах возвести в квадрат, потом массу тела в килограммах разделить на полученную цифру.
# # # (вес, рост)
# data = [
#     (82, 191),
#     (68, 174),
#     (90, 189),
#     (73, 179),
#     (76, 184)
# ]
# # РЕШЕНИЕ
# result = sorted(data, key = lambda x: x[0] / x[1] ** 2)
# print (result)
# print(min(data, key=lambda x: x[0] / x[1] ** 2))  # отбор по ключу (кортеж с минимальным индексом массы тела)

# # ОТКРЫТИЕ ФАЙЛА
# myFile = open("filename.txt","rt",encoding = "utf8")
# print (myFile.read())


# # ----------------------------------------ООП----------------------------------------------

# class Event:
#     def __init__(self, timestamp, event_type, session_id):
#         self.timestamp = timestamp
#         self.type = event_type
#         self.session_id = session_id
# events = [
#     {
#         "timestamp": 1554583508000,
#         "type": "itemViewEvent",
#         "session_id": "0:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
#     },
#     {
#         "timestamp": 1555296337000,
#         "type": "itemViewEvent",
#         "session_id": "0:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
#     },
#     {
#         "timestamp": 1549461608000,
#         "type": "itemBuyEvent",
#         "session_id": "0:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
#     },
# ]
# for event in events:
#     event_obj = Event(timestamp=event.get("timestamp"),
#                         event_type=event.get("type"),
#                         session_id=event.get("session_id"))
#     print(event_obj.timestamp)


# # Команда проекта «Дом питомца» планирует большой корпоратив для своих клиентов. 
# # Вам необходимо написать программу, которая позволит составить список гостей. 
# # В класс «Клиент» добавьте метод, который будет возвращать информацию только 
# # об имени, фамилии и городе клиента.
# # Затем создайте список, в который будут добавлены все клиенты, и выведете его в консоль.

# class Customers:
#     def __init__(self, first_name,second_name,city, balance):
#         self.first_name = first_name
#         self.second_name = second_name
#         self.balance = balance
#         self.city=city
#     def __str__(self):
#         return f'''"{self.first_name} {self.second_name}". {self.city}. Баланс: {self.balance} руб.'''

#     def get_guest(self):
#         return f'{self.first_name} {self.second_name},г. {self.city}'
# costomer_1 = Customers('Иван','Петров','Москва',50)
# costomer_2 = Customers('Владимир','Зайцев','Кострома',50)
# costomer_3 = Customers('Олеся','Янина','Новосибирск',50)
# guest_list=[costomer_1,costomer_2,costomer_3]
# for guest in guest_list:
#     print(guest.get_guest())


# РАБОТА С БИБЛИОТЕКАМИ, НАПИСАНИЕ БОТА, ИМПОРТИРОВАНИЕ и т.д
# import requests

# r = requests.get('https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html') # делаем запрос на сервер по переданному адресу
# print(r.content)
# -----------------------------------------------------------------

# import requests
# import json # импортируем необходимую библиотеку

# r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
# texts = json.loads(r.content) # делаем из полученных байтов python объект для удобной работы
# print(type(texts)) # проверяем тип сконвертированных данных

# for text in texts: # выводим полученный текст. Но для того чтобы он влез в консоль оставим только первые 50 символов.
#     print(text[:50], '\n')
# ----------------------------------------------------------------

# # ПРЕОБРАЗОВАНИЕ ДАННЫХ В СЛОВАРЬ PYTHON

# import requests
# import json

# r = requests.get('https://api.github.com')
# d = json.loads(r.content) # делаем из полученных байтов python объект для удобной работы

# print(type(d))
# print(d['following_url']) # обращаемся к полученному объекту как к словарю 
#                           # и попробуем напечатать одно из его значений
# ----------------------------------------------------------------------------------------

# import requests
# import json

# r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
# r = json.loads(r.content)

# print(r[0])